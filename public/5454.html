<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>スーパークレイジー君 5454</title>
<style>
  table {background-color:gray;}
  td {width: 64px;height: 64px;border-radius: 32px;}
  .box{display: flex;}
</style>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.7/vue.min.js"></script>
</head>
<body>
<div id="app">
  <h3>スーパークレイジー君 5454</h3>
  <a class="twitter-share-button"
    href="https://twitter.com/intent/tweet"
    data-size="large">
    Tweet
  </a>
  <p>キーボードの矢印キーとスペースキーで操作します</p>
  <input type="button" @click="startFn" value="START" v-if="!gameStart">
  <input type="button" @click="restartFn" value="RESTART"  v-if="gameOver">
  <div class="box" v-if="gameStart">
    <table>
          <tr v-for="i in H">
            <td v-for="j in W" :style="{ backgroundImage:images[stage[i-1][j-1]] }"></td>
          </tr>
      </table>
      <table>
        <tr v-for="i in 2">
            <td :style="{ backgroundImage: images[next[i - 1]] }"></td>
        </tr>
      </table>
   </div>
</div>
<script>
var vm = new Vue({
  el: '#app',
  data: {
    H: 13,
    W: 6,
    // 盤面の情報
    stage: [], // 0 | Colors
    // 現在操作中のblockの情報
    currentBlockVector: [], // blockの向き
    blockX: 0, // blockの現在の座標
    blockY: 0,
    prevBlockPosition: [], // x,yの順
    blockColor: [], // blockの色

    next : [Math.floor(Math.random() * 5) + 1, Math.floor(Math.random() * 5) + 1],
    timerID: null,
    otitaFlag:false,
    gameStart: false,
    gameOver: false,
    images: ['url(image/puyo/00_gray.png)', 'url(image/puyo/01_orange_64.png)', 'url(image/puyo/02_green_64.png)', 'url(image/puyo/03_blue_64.png)', 'url(image/puyo/04_purple_64.png)', 'url(image/puyo/05_red_64.png)'],
    saveData : null,
  },
  methods: {
    startFn: function () {
      this.saveData = JSON.stringify(this.$data);
      // 縦横i*jのstageを作成（左上がstage[0][0]）
      for (var i = 0; i < this.H; i++) {
        this.stage[i] = [];
        for (var j = 0; j < this.W; j++) {
          this.stage[i][j] = 0;
        }
      }

      this.gameStart = true;
      this.createFn();
      this.timerID = setInterval(this.fallFn, 500);
    },
    // 操作するblockのセットを作る
    createFn: function () {
      this.prevBlockPosition = [];
      this.blockX = 2;
      this.blockY = 1;
      this.currentBlockVector = [[0, 0], [0, -1]];
      // 5面サイコロを二回振って出たそれぞれの色をblockColorに格納
      this.blockColor = [this.next[1], this.next[0]];
      // 次の分をふっておく
      this.next = [Math.floor(Math.random() * 5) + 1, Math.floor(Math.random() * 5) + 1];

      this.drawFn(false, 0, 0);
    },
    fallFn: function () {
      if (this.canMoveTo(false, 0, 1)) {
        this.drawFn(false, 0, 1);
      } else {
        // 下まで落ちてきたならば、blockが消えるか確認
        this.otitaFlag = true;
        clearInterval(this.timerID);
        this.timerID = setInterval(this.rensaFn, 200);
        }
    },
    canMoveTo: function (rotate, dx, dy) {
      // 仮の盤面stageを新たに作る
      var stage = this.stage.map(v => v.slice());

      var currentBlockVector = this.currentBlockVector.map(v => v.slice());

      this.prevBlockPosition.forEach(v => {
        stage[v[1]][v[0]] = 0;
      });

      if (rotate) {
        currentBlockVector = this.rotateBlock(currentBlockVector)
      }
      var flag = currentBlockVector.every(v => {
        var x = v[0] + this.blockX + dx;
        var y = v[1] + this.blockY + dy;
        return (this.isInsideStage(y,x) && stage[y][x] == 0);
      });
      return flag;
    },
    rotateBlock: function (currentBlockVector) {
      return currentBlockVector = currentBlockVector.map(v => [v[1] * -1, v[0]]); // ([[0, 0], [0, -1]]) => {return [[0, 1],[0, 0]}
    },
    drawFn: function (rotate, dx, dy) {
      this.prevBlockPosition.forEach(v => {
        this.stage[v[1]][v[0]] = 0;
      });
      this.prevBlockPosition = [];
      if (rotate) {
        this.currentBlockVector = this.rotateBlock(this.currentBlockVector)
      }
      this.blockX += dx;
      this.blockY += dy;
      this.currentBlockVector.forEach((v, i) => {
        var x = v[0] + this.blockX;
        var y = v[1] + this.blockY;
        if (this.stage[y][x] != 0) {
          this.gameOver = true;
        }
        this.stage[y][x] = this.blockColor[i];
        this.prevBlockPosition.push([x, y]);
      });
      if (this.gameOver) {
        clearInterval(this.timerID);
      }
      this.$forceUpdate();
    },
    isInsideStage: function (y,x) {
      return y >= 0 && y < this.H && x >= 0 && x < this.W
    },
    rensaFn: function () {
      // blockが下まで落ちて何かあるとき
      if (this.kuzureruFn() || this.removeFn()){
        // 強制的に再描画させる
        this.$forceUpdate();

      // blockが下まで落ち切ってなにも起きなかったとき
      } else {
        // 500ミリ秒待って新しいblockを落とす
        clearInterval(this.timerID);
        this.timerID = setInterval(this.fallFn, 500);
        this.createFn();

        this.otitaFlag = false;
        }
    },
    kuzureruFn: function () {
      // 下にあるblockが壊れている場合は下の行から順にその一つ上の行のblockを上書きしていく
      // 移動させたらflagをtrueにして返す
      var flag= false;
        for (var i = this.H - 2; i >= 0; i--) {
          for (var j = 0; j < this.W; j++) {
            if (this.stage[i + 1][j] == 0 && this.stage[i][j] != 0) {
              //ある場所にblockがなく、その上にはある場合は一つ下に移動させる
              this.stage[i + 1][j] = this.stage[i][j];
              this.stage[i][j] = 0;
              flag = true;
            }
          }
        }
      return flag;
    },
    removeFn: function () {
      // 隣り合うblockの色を確認する
      // 4つ以上同じ色が並んだ場合はblockを消して、flagをtrueにして返す
      var flag = false;
      var dydx = [[-1, 0], [0, 1], [1, 0], [0, -1]];
      for (var i = 0; i < this.H; i++) {
        for (var j = 0; j < this.W; j++) {
          var iro = this.stage[i][j];
          
          if (iro == 0) continue; // 色がある = blockがある 場合は以下を実行
          // 仮の盤面stageを新たに作る
          var stage = this.stage.map(v => v.slice());
          // 無限ループを防ぐため、一度確認されたマスは空のマスとして扱う
          stage[i][j] = 0;

          var onazi = 1;
          var memo = [[i, j]];
          while (memo.length != 0) {
            var m = memo.shift(); // m = [i,j] memo = []
            // [i][j]の隣のblockの色を確認する
            dydx.forEach(v => {
              var y = m[0] + v[0];
              var x = m[1] + v[1];

              if (this.isInsideStage(y,x)) {
                // 最初に取り出したblockと同じ色ならば
                if (stage[y][x] == iro) {
                  // 同じ色カウンターを+1してそのマスを原点候補の配列に追加する
                  onazi++;
                  memo.push([y, x]);

                  // 無限ループを防ぐため、一度確認されたマスは空のマスとして扱う
                  stage[y][x] = 0;
                }
              }
            });
          }
          if (onazi >= 4) {
            // 同じblockが4つ以上並んでいた場合は、空にしたマスをそのまま本物の盤面に入れる
            flag = true;
            this.stage = stage.map(v => v.slice());
          }
        }
      }
      return flag;
    },
    keydownFn: function (rotate, dx, dy) {
      if (!this.gameOver && !this.otitaFlag && this.canMoveTo(rotate, dx, dy)) {
        this.drawFn(rotate, dx, dy);
      }
    },
    restartFn: function () {
      var obj = JSON.parse(this.saveData);
      for (var k in obj) this[k] = obj[k];
      this.startFn();
    },
  }
});

document.onkeydown = function (e) {
  if (e.keyCode == 32) vm.keydownFn(true, 0, 0); //space
  else if (e.keyCode == 37) vm.keydownFn(false, -1, 0); //left
  else if (e.keyCode == 40) vm.keydownFn(false, 0, 1); //down
  else if (e.keyCode == 39) vm.keydownFn(false, 1, 0); //right
};
</script>
</body>
</html>